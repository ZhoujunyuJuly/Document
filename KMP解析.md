@[TOC]

# 1.引入思考

![的](/Users/zhoujunyu/Library/Application Support/typora-user-images/image-20220105095458817.png)

我们首先假设是一个毫无算法基础的同学，会怎么写这道题呢？

应该是对这两个字符串进行依次匹配。虽然繁琐了一点，但总能匹配出结果。其实这也就是算法开始的基础和雏形。KMP没有在开辟一个新方法，而只是对原有的基础方法进行浓缩，提炼。

当我们看到以上两个字符串，用==我们的肉眼可以清晰的从第一次匹配，跳到第二次匹配。为什么呢？==因为当我们匹配到第一个 d 时，发现匹配失败了，那么至少主串中的 a b c 前三个字符串，都无法匹配上模式串中的 a b，我们只需要找到在原来已经经过匹配的主串中（即 a b c a b），是否还有能和模式串的头部（ a b c a b d）能匹配上的。如果有，我们就从第二次匹配的位置开始。如果没有，我们直接移动模式串在 d 之后。

理解了跳跃型的匹配，==那么我们怎么精确的找到第二次匹配的位置呢？==

如果我们一次性从第一个字符串，跳到最后一个字符串，如（a a c a a）, a 和 a 能匹配上，但是由于跨度之大，我们错过了 a a 和 a a 的匹配，有可能正确的匹配答案就在从 a a 开始的字符串中。所以我们要竭尽可能的让从尾部开始的匹配长度越长，长到我们能匹配到的极限，才能不会遗漏匹配。

==那这个首尾的匹配是否有规律的呢？==我们是在每一次匹配的循环中，去检索该匹配的首尾，即在循环之外再加一层循环，只为了得到下一次跳跃匹配的位置（这样明显听起来就更繁琐了），还是有没有更便捷的方法，让我们最终能使算法更简洁？

注意到，当我们需要匹配首尾位置时，即模式串与主串的前部分是能匹配上的，只是遇到了一个无法匹配的字符串，我们需要移动模式串的位置，开始下一个匹配。那么我们每次遇到需要匹配时的字符串，都是存在于模式串中的！

我们甚至可以在开始匹配前，通过研究这个模式串，能得到我们每一次匹配失败时，需要查询首尾信息的子串！这样我们一遇到无法匹配的情况，就通过我们提前已经找到的，在该子串中首尾能匹配上的最长字符串，移动到下一个位置！

==所以我们算法的第一个核心，就是研究模式串==，找到从索引 0 开始，长度从1依次到模式串长度的子串的，所有最长首尾字符串（即模式串为 a b c a b 时，从索引 0 即 a 开始，a / a b / a b c / a b c a ，这些子串的首尾信息 ）！

# 2.开始研究模式串

## 2.1 普遍情况

我们先假设一个比较普遍的情况，模式串为  ｜ a b a c a b a b ｜d，我们先匹配到 d 最后一位，这种情况

<img src="/Users/zhoujunyu/Library/Application Support/typora-user-images/image-20220105113511033.png" alt="image-20220105113511033" style="zoom:50%;" /> 

### 2.1.1 匹配算法

对于从索引 0 - 7 的情况，我们要怎么匹配得到它的最长呢？最先想到的应该是暴力算法。

- **暴力算法**：使用双层循环，或者双指针，依次遍历，找到最长匹配的首尾字符串

  ```java
  //伪代码--双层循环
  //这是第一层循环，求解一个最长字符串，我们要对模式串的每一个子串，都求出最长匹配字符串
  int maxLen = 0;
  for(int i = 1 ; i < str.len;i++){
      //从当前字符串开始匹配，如果与首字符串相等，就依次匹配，直到不匹配位置，算出当前长度
  		int start = i;
      //每次从首字符串开始匹配
   	 	int head = 0;
    	while( start < str.len && head < str.len && str[start] == head){
     	 	start++;
      	head++;
    	}
      //如果匹配到了最后一位，说明满足首尾有相等字符串，存储改长度
      if( start == str.len){
         	maxLen = Math.max(maxLen,head + 1);
          //一般来说，从左开始往右执行，最先满足条件的应该为最长字符串了，所以跳出循环即可
          break;
      }
  }
  ```


但这种方法始终不够简洁，且一个 for + while 的循环，仅能求出一个子串的最长匹配字符串，我们需要的是模式串的 **每一个子串** 的最长匹配字符串。这显然增大的工作量，说不定还没有暴力算法来得快。

我们是不是可以用到==动态规划呢==？  

<img src="/Users/zhoujunyu/Library/Application Support/typora-user-images/image-20220105113511033.png" alt="image-20220105113511033" style="zoom:50%;" />

当我们要求 0 - 7 的首尾字符串时，可不可以利用 0 - 6 的首尾字符串信息？

我们假设 0 - 6 的首尾字符串长度表示为 d[6] = 3，这是已知信息。再假设当前模式串为 modelStr。

在求 d[7] 时，我们会遇到以下几种情况：

- 如果 modelStr[3] == modelStr[7]，且d[6] = 3，则相对于 d[6] 我们的首尾匹配长度增加一位，为 d[7] = d[6] + 1;
- 如果 modelStr[3] != modelStr[7] 时，我们可以知道 d[7] <= d[6] 一定成立，也就是在 0 - 2 中找是否还有能和尾部匹配上的；那我们先找在 0 - 2 内部，有没有首尾匹配串呢？

这里引入一段思考：

我们可以用肉眼先得出 d[2] = 1，匹配字符串为 a ，那这个信息是否有用呢？

因为 0 - 2 和 4 - 6 是能匹配，也就是完全相等的。如果 modelStr[0] == modelStr[2] ，那么必然 modelStr[4] == modelStr[6]，而我们早就知道 modelStr[0] == modelStr[4] ，所以与之对称的4个数都是相等的，即 0 2 4 6 都相等。

所以 d[2] 的匹配字符串，也必然会匹配到 0 - 6 的尾部，即 modelStr[0] == modelStr[6]，我们==又一次找到一个首尾匹配的子字符串==！所以我们可以接着继续比较在它之后的 1 号是否与我们当前的 7 号字符串相等，便又一次回到我们上面讨论的两种情况循环。

**总结来说**，我们不断利用已知信息——在前置位匹配完的首尾字符串长度，进行动态递归匹配。

  - 如果存在匹配字符串，再将我们当前的字符串（即 7 号），与匹配完的字符串的后一位（即 3 号）进行匹配，如果相等，我们找到了目标字符串，匹配到此结束；
  - 如果没有，再往更短的字符串匹配，这个更短的字符串，在我们的首部 或者 尾部，单条字符串内部寻找。继续循环匹配，直到结束。

所以这里我们引出一个问题，就是匹配的边界。

  ### 2.1.2 边界问题

**1.对于尾部**

我们首先看尾部，当匹配到 8 号时，说明前面 0 - 7 都已经能匹配上，如果 8 号也能匹配上，则匹配结束；如果 8 号不能匹配上，我们需要查看 d[7] = 2，再把首部的前2位移过来，将 modelStr[2] 与主串匹配，如果依旧不能匹配，我们要再次移动，这点跟我们上一步的过程类似。具体移动，是我们下一步的事，现在先不讨论。

由以上过程我们可以知道，轮到 8 号匹配时，要么结束，要么只需要利用到 d[7] 的信息。再退一步，就算我们要计算 d[8] ，仔细想想，我们的计算 d[8] 什么时候可以用上？得要 modelStr[9] 匹配不上时，我们要看看前 0 - 8 位要怎么移动效率最高吧。可关键是，没有 modelStr[9] 呀，8号能匹配上就已经结束了。

所以对于一个长度 modelStr.len = 9 的字符串，我们只需要得到它前 8 位的首尾匹配字符串，即 0 - 7 号。

**2.对于首部**

<img src="/Users/zhoujunyu/Library/Application Support/typora-user-images/image-20220105163827846.png" alt="image-20220105163827846" style="zoom:50%;" />

  我们先分析三种首部匹配情况：

- 第0个匹配：当不相等时，我们直接往后移一位
- 第1个匹配：当 index = 1时，不匹配，我们同样往后移动一位
- 第2个匹配：我们知道 d[2] = 1，出现了首尾相等的字符串，所以我们此时只移动一位。想象如果模式串不是为 a a c ，而是 mainStr= “a b b” ，modelStr = “a b c” 的情况呢，此时 d[2] = 0，表明在我们匹配过的字符串中没有再能与模式串的首部匹配得上的，所以我们不再考虑在前置部分（也就是 “a b"）去匹配模式串。

虽然都是对于前两种情况，都是往后移动一位，但是在程序中的含义是不同的。

我们匹配时有一个需要注意的地方时，我们只遍历一次主串，当发现不匹配时，我们移动的是模式串，对于 d[6] = 3 的情况，我们留模式串的前3个字符串，将第四个字符串与 mainStr[7]对齐，即 modelStr[3] == mainStr[7]，由于数组的索引从 0 开始，意外发现首尾匹配字符串的长度刚好等于我们匹配对齐的位置。

即 首尾匹配字符串的长度为 3 ，我们把 索引值为 3 的模式串字符串，对齐当前待匹配的主串字符 7 号。

<img src="/Users/zhoujunyu/Library/Application Support/typora-user-images/image-20220105183403080.png" alt="image-20220105183403080" style="zoom:50%;" />

所以我们得到了一个核心知识点，==d[i] = n，这个 n 表示 **模式串** 下一次对齐的索引==，且主串的索引不动。

那么第0个、第1个、第2个匹配的区别究竟在哪里呢？我们看看图。

![image-20220105184315699](/Users/zhoujunyu/Library/Application Support/typora-user-images/image-20220105184315699.png)

- 第0个匹配：从第0个字符串起就不匹配，此处主串处于索引为 0 的位置，在保持主串不动的前提下，模式串的 -1 索引对齐此时的主串。而对于模式串来说，甚至我们都还没开始比，连前置位字符串都没有，都不存在索引为 0 的字符串作为前置字符串，所以我们写为 d[-1] = -1（这是错误的表达，此处只是为了说明得更清楚）

- 第1个匹配：第1个字符串能匹配上，但是第二个字符串不能匹配了，我们此时也不讲究什么KMP算法，反正是要往后移 1 位，即此时将主串索引为 1 的位置，对齐模式串索引为 0 的位置，看起来是 d[0] = 0

  > 而我们的前置位字符串只有索引为 0 的 a ，它本身是没有首尾匹配字符串的，因为首尾的字符串不能包含首部的第一个字符串（想一想为什么不能包含？因为包含了首部第一个字符串的首尾匹配字符串，最大长度永远是它本身，既没有意义，同时，运用到匹配时会一直原地移动，无法向后移）。所以 d[0] = 0，发现含义和以上我们作出的移动位置结果是一样的，即 d[0] = 0;

- 
